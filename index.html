<!DOCTYPE html>
<html lang="en">
<head>
    <title>Sheet Music Generator</title>
    <link rel="icon" href="./music.svg">
    <link rel="preload" href="index.css">
    <style>
    body {
        margin: 0;
        /* overflow:hidden; */
    }
    #animation {
        position:absolute;
        top: 0;
    }
    #sound {
        position:absolute;
        top: 10px;
        left: 10px;
    }
    #randomise {
        position: absolute;
        top: 10px;
        left: 200px;
    }
    #distance {
        position: absolute;
        top: 10px;
        left: 400px;
    }
    #pause {
        position: absolute;
        top: 10px;
        left: 600px;
    }
    #stop {
        position: absolute;
        top: 10px;
        left: 800px;
    }
    </style>
</head>
<body>
    <canvas id="sheet-music"></canvas>
    <canvas id="animation"></canvas>
    <button id="sound" onClick="play()">Play Sound</button>
    <button id="randomise" onClick="randomise()">Randomise</button>
    <button id="pause" onClick="pausePlayback()">Pause</button>
    <button id="stop" onClick="stopPlayback()">Stop</button>
    <div id="distance"></div>
</body>
<script>
    'use strict'
    var CANVAS = document.getElementById('sheet-music')
    var ANIMATION = document.getElementById('animation')
    var ctxAnim = ANIMATION.getContext('2d')
    var ctx = CANVAS.getContext('2d')
    ctx.font = "40px bravura"


    var SOUND

    var BUTTON = document.getElementById('sound')

    const songObject = {}
    const songDurations = []
    const songNoteNames = []

    const noteHead = {
        4:      `\ue0a2`,
        2:      `\ue0a3`,
        1:      `\ue0a4`,
        0.5:    `\ue0a4`,
        0.25:   `\ue0a4`
    }

    const frequencyNoteMap = {
        "C0":16.05,
        "C#0/Db0":17.01,
        "D0":18.02,
        "D#0/Eb0":19.09,
        "E0":20.23,
        "F0":21.43,
        "F#0/Gb0":22.70,
        "G0":24.05,
        "G#0/Ab0":25.48,
        "A0":27.00,
        "A#0/Bb0":28.61,
        "B0":30.31,
        "C1":32.11,
        "C#1/Db1":34.02,
        "D1":36.04,
        "D#1/Eb1":38.18,
        "E1":40.45,
        "F1":42.86,
        "F#1/Gb1":45.41,
        "G1":48.11,
        "G#1/Ab1":50.97,
        "A1":54.00,
        "A#1/Bb1":57.21,
        "B1":60.61,
        "C2":64.22,
        "C#2/Db2":68.04,
        "D2":72.08,
        "D#2/Eb2":76.37,
        "E2":80.91,
        "F2":85.72,
        "F#2/Gb2":90.82,
        "G2":96.22,
        "G#2/Ab2":101.94,
        "A2":108.00,
        "A#2/Bb2":114.42,
        "B2":121.23,
        "C3":128.43,
        "C#3/Db3":136.07,
        "D3":144.16,
        "D#3/Eb3":152.74,
        "E3":161.82,
        "F3":171.44,
        "F#3/Gb3":181.63,
        "G3":192.43,
        "G#3/Ab3":203.88,
        "A3":216.00,
        "A#3/Bb3":228.84,
        "B3":242.45,
        "C4":256.87,
        "C#4/Db4":272.14,
        "D4":288.33,
        "D#4/Eb4":305.47,
        "E4":323.63,
        "F4":342.88,
        "F#4/Gb4":363.27,
        "G4":384.87,
        "G#4/Ab4":407.75,
        "A4":432.00,
        "A#4/Bb4":457.69,
        "B4":484.90,
        "C5":513.74,
        "C#5/Db5":544.29,
        "D5":576.65,
        "D#5/Eb5":610.94,
        "E5":647.27,
        "F5":685.76,
        "F#5/Gb5":726.53,
        "G5":769.74,
        "G#5/Ab5":815.51,
        "A5":864.00,
        "A#5/Bb5":915.38,
        "B5":969.81,
        "C6":1027.47,
        "C#6/Db6":1088.57,
        "D6":1153.30,
        "D#6/Eb6":1221.88,
        "E6":1294.54,
        "F6":1371.51,
        "F#6/Gb6":1453.07,
        "G6":1539.47,
        "G#6/Ab6":1631.01,
        "A6":1728.00,
        "A#6/Bb6":1830.75,
        "B6":1939.61,
        "C7":2054.95,
        "C#7/Db7":2177.14,
        "D7":2306.60,
        "D#7/Eb7":2443.76,
        "E7":2589.07,
        "F7":2743.03,
        "F#7/Gb7":2906.14,
        "G7":3078.95,
        "G#7/Ab7":3262.03,
        "A7":3456.00,
        "A#7/Bb7":3661.50,
        "B7":3879.23,
        "C8":4109.90,
        "C#8/Db8":4354.29,
        "D8":4613.21,
        "D#8/Eb8":4887.52,
        "E8":5178.15,
        "F8":5486.06,
        "F#8/Gb8":5812.28,
        "G8":6157.89,
        "G#8/Ab8":6524.06,
        "A8":6912.00,
        "A#8/Bb8":7323.01,
        "B8":7758.46
    }
    const offsetNoteMap = {
        "C0":38,
        "D0":37,
        "E0":36,
        "F0":35,
        "G0":34,
        "A0":33,
        "B0":32,
        "C1":31,
        "D1":30,
        "E1":29,
        "F1":28,
        "G1":27,
        "A1":26,
        "B1":25,
        "C2":24,
        "D2":23,
        "E2":22,
        "F2":21,
        "G2":20,
        "A2":19,
        "B2":18,
        "C3":17,
        "D3":16,
        "E3":15,
        "F3":14,
        "G3":13,
        "A3":12,
        "B3":11,
        "C4":10,
        "D4":9,
        "E4":8,
        "F4":7,
        "G4":6,
        "A4":5,
        "B4":4,
        "C5":3,
        "D5":2,
        "E5":1,
        "F5":0,
        "G5":-1,
        "A5":-2,
        "B5":-3,
        "C6":-4,
        "D6":-5,
        "E6":-6,
        "F6":-7,
        "G6":-8,
        "A6":-9,
        "B6":-10,
        "C7":-11,
        "D7":-12,
        "E7":-13,
        "F7":-14,
        "G7":-15,
        "A7":-16,
        "B7":-17,
        "C8":-18,
        "D8":-19,
        "E8":0,
        "F8":0,
        "G8":0,
        "A8":0,
        "B8":0,
    }

    const cPentatonicMajor = [
        "C5",
        "D5",
        "E5",
        "G5",
        "A5"
    ]
    const cMajor = [
        /*"C4", 
        "D4",
        "E4",
        "F4", */
        "G4",
        "A4",
        "B4",
        "C5",
        "D5",
        "E5",
        "F5",
        "G5"
    ]

    let durations = [
        0.25, 0.5, 1, 2
    ]
    const bpm = 60
    const numberOfMeasures = 3
    const timeSignatureBeats = 4
    // timeSignatureUnit = 4
    const secondsPerBeat = 60 / bpm         
    var topLine = 50
    var distanceBetweenStaves = 160
    var startStaffX = 40
    var initialOffset = 100
    var bufferToEnd = 20
    var barWidth = (window.innerWidth - 2 * startStaffX - initialOffset - bufferToEnd)
    const numberOfMeasuresPerBar = 2
    const numberOfBeatsPerBar = numberOfMeasuresPerBar * timeSignatureBeats
    var unitDistance = barWidth / (numberOfBeatsPerBar * secondsPerBeat)

    function randomise(){
        SOUND = new AudioContext()

        const noteList = cMajor
        let currentDistance = 0
        let index = 0
        Object.keys(songObject).forEach(noteNumber => delete songObject[noteNumber])
        
        Array(numberOfMeasures).fill(null).forEach((nothing, measure) => {                 // Number of Musical Measures
        while (currentDistance < timeSignatureBeats) {
            const noteLengthUnit = durations[Math.floor(Math.random()*durations.length)]
            // console.log(durations, noteLengthUnit, secondsPerBeat)
    
            songObject[index] = {
                duration: noteLengthUnit * secondsPerBeat, 
                name: noteList[Math.floor(Math.random() * noteList.length)]
            }

            currentDistance += noteLengthUnit       
            const distanceLeft = timeSignatureBeats - currentDistance
            // console.log("distance Left", distanceLeft, typeof currentDistance)
            if (durations.at(-1) > distanceLeft){              // Cut out notes which would exceed bar length
                durations = durations.filter(dur => dur <= distanceLeft)
            }
            index++
        }
        currentDistance = 0
        durations = [0.25, 0.5, 1, 2]

    })
    // console.log(songObject)
    const totalSongDistance = Object.values(songObject).reduce((a,obj) => a + obj.duration * unitDistance, 0)

    const distanceDiv = document.getElementById("distance")
    distanceDiv.innerText = `${totalSongDistance}`

    fitToScreen()
    }

    // console.log(songObject, songDurations, songNoteNames)
    
    function fitToScreen() {
        CANVAS.width = window.innerWidth
        CANVAS.height = window.innerHeight * 2
        ANIMATION.width = window.innerWidth
        ANIMATION.height = window.innerHeight * 2
        barWidth = window.innerWidth - 2 * startStaffX - initialOffset - bufferToEnd
        unitDistance = barWidth / (numberOfBeatsPerBar * secondsPerBeat) 
        drawSheet()
    }
   
    
    
    window.addEventListener('resize', fitToScreen)
    
    function drawSheet() {
        var {width, height} = CANVAS
        ctx.fillStyle = "black"
        ctx.font = "40px bravura"
        ctx.fillText("\uE084", startStaffX + 43, topLine + 10)                                 // Time signatures  - treble
        ctx.fillText("\uE084", startStaffX + 43, topLine + 30)
        
        ctx.fillText("\uE084", startStaffX + 43, topLine + 60 + 10)               //  - bass
        ctx.fillText("\uE084", startStaffX + 43, topLine + 60 + 30)

        // |~~~~~~~~~~~~~~ -- | Note placement | -- ~~~~~~~~~~~~~~| \\
        
        var halfToneDistance = 5
        var songDistance = 0        // The number of pixels from the start to the current note
        // var songLineDistance = 0
        var totalSongDistance = Object.values(songObject).reduce((a,obj) =>
            a + obj.duration * unitDistance, 0)
        var numberOfStaves = Math.ceil(totalSongDistance/barWidth)

        
        Object.values(songObject).forEach((obj,noteNumber)=> {
            const noteDuration = obj.duration
            const durationUnit = obj.duration / secondsPerBeat
            
            ctx.fillText(noteHead[durationUnit],// Draw note head
                startStaffX + initialOffset + songDistance % barWidth, 
                topLine + 0.5 + halfToneDistance * offsetNoteMap[obj.name] + distanceBetweenStaves * Math.floor(songDistance / barWidth))
            if (durationUnit <= 2) {            // Draw note bars and tails
                if (offsetNoteMap[obj.name] > 4) {
                    ctx.fillRect(
                        startStaffX + initialOffset + songDistance % barWidth + 10,
                        topLine - 1 + halfToneDistance * offsetNoteMap[obj.name] + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                        2,
                        -30)
                    if (durationUnit === 0.5) {
                        ctx.fillText('\ue240', 
                        startStaffX + initialOffset + songDistance % barWidth + 10, 
                        topLine - 1 + halfToneDistance * offsetNoteMap[obj.name] + distanceBetweenStaves * Math.floor(songDistance / barWidth) - 35)
                    }
                    else if (durationUnit === 0.25) {
                        ctx.fillText('\ue242', 
                        startStaffX + initialOffset + songDistance % barWidth + 10, 
                        topLine - 1 + halfToneDistance * offsetNoteMap[obj.name] + distanceBetweenStaves * Math.floor(songDistance / barWidth) - 35)
                    }
                }
                else {
                    ctx.fillRect(
                        startStaffX + initialOffset + songDistance % barWidth,
                        topLine + 0.5 + halfToneDistance * offsetNoteMap[obj.name] + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                        2,
                        30)
                    if (durationUnit === 0.5) {
                        ctx.fillText('\ue241', startStaffX + initialOffset + songDistance % barWidth,
                        topLine - 1 + halfToneDistance * offsetNoteMap[obj.name] + distanceBetweenStaves * Math.floor(songDistance / barWidth) + 35)
                    }
                    else if (durationUnit === 0.25) {
                        ctx.fillText('\ue243', startStaffX + initialOffset + songDistance % barWidth,
                        topLine - 1 + halfToneDistance * offsetNoteMap[obj.name] + distanceBetweenStaves * Math.floor(songDistance / barWidth) + 35)
                    }
                }
            }
            if (obj.name === "C4") {            // C4 bar
                ctx.fillRect(
                    startStaffX + initialOffset + songDistance % barWidth - 0.25 * 30, 
                    topLine + halfToneDistance * offsetNoteMap["C4"] + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                    30,
                    1)      
            }
            
            songDistance += unitDistance * noteDuration
        })
        // console.log(Math.ceil(totalSongDistance))
        // console.log(numberOfStaves, numberOfBeatsPerBar / timeSignatureBeats)
        Array(numberOfStaves).fill(null).forEach((v, index) => {                                     // Number of grand staves
            ctx.font = `100px bravura`
            ctx.fillText("\uE000", 25, topLine + 100 + distanceBetweenStaves * index)               // Staff Bracket
            ctx.font = "40px bravura"
            ctx.fillText("\uE050", startStaffX + 10, topLine + 30 + distanceBetweenStaves * index)  // Treble Clef
            ctx.fillText(`\ue062`, startStaffX + 10,topLine + 70.5 + distanceBetweenStaves * index) // Bass Clef  
            
            Array(numberOfMeasuresPerBar).fill(null).forEach((nothing, measureIndex) => {           // Measure bars
                if (!measureIndex) return
                function drawLine(offset) {ctx.fillRect(
                    barWidth / (numberOfBeatsPerBar / timeSignatureBeats) * measureIndex + startStaffX + initialOffset - offset, 
                    topLine + distanceBetweenStaves * index, 
                    1.5, 100)}
                drawLine(5)
                }
            )

            Array(2).fill(null).forEach((v, ind) => {                                   // Treble and Bass staves
                ctx.fillRect(startStaffX + 10,topLine + 50 + distanceBetweenStaves*index,30,1) // C4 bar
                
                ctx.fillRect(startStaffX,topLine + distanceBetweenStaves * index,2,100)        // Start Staff
                ctx.fillRect(width - startStaffX,topLine + distanceBetweenStaves * index,2,101)  // End staff

                

                Array(5).fill(null).forEach( (v,i) =>                                   // Staff lines
                    ctx.fillRect(startStaffX, (topLine) + 10 * i + 60 * ind + distanceBetweenStaves * index, width - 2 * startStaffX, 1) )
            })  
            
        })

    }
   


   

        
        // |~~~~~~~~~~~~~~ -- | Bar animation | -- ~~~~~~~~~~~~~~| \\

        var x = 0
        var y = 0
        var dir = "FORWARD"
        var start = undefined, pauseTime = 0, elapsed
        var animationPaused = false
        var animationStopped = false
        let i = 0

        // var songDistance = 0
        var currentStaff = 0
    

    function loop(timestamp) {
        if (start === undefined) {
            start = timestamp
        }
        if (animationPaused) {pauseTime = timestamp - start - elapsed ; window.requestAnimationFrame(loop) ; return}
        if (animationStopped) {x = 0;start = undefined;pauseTime = 0;i = 0;ctxAnim.clearRect(0, 0, ANIMATION.width, ANIMATION.height);animationStopped = false; return}
        // const pauseTime = resumeTimeStart = pauseTimeStart
        elapsed = timestamp - start - pauseTime
        // Dynamic line movement, based on duration of note and distance to next note

        const totalTimeWhenNextNotePlayed = Object.values(songObject).slice(0,i).reduce((a,v) => a + v.duration, 0) * unitDistance
        // console.log(currentStaff, i)
        if (x + barWidth * currentStaff >= Object.values(songObject).slice(0,i).reduce((a,v) => a + v.duration, 0) * unitDistance
         && i <  Object.values(songObject).length - 1) i++
        
        const durationOfNotesPlayed = Object.values(songObject).slice(0,i-1).reduce((a,v) => a + v.duration, 0) * 1000
        const noteElapsed = elapsed - durationOfNotesPlayed
        const noteDuration = songObject[i-1].duration
        // console.log(noteDuration, durationOfNotesPlayed)
        // songDistance = Object.values(songObject).slice(0,i).reduce((a,obj) => a + obj.duration * unitDistance, 0)

        
        x = (durationOfNotesPlayed*0.001 * unitDistance) % (barWidth) + (noteElapsed*0.001/noteDuration) * unitDistance * noteDuration
        // console.log(x.toFixed(1), ((noteElapsed*0.001/noteDuration)*unitDistance*noteDuration).toFixed(1), (durationOfNotesPlayed + noteElapsed).toFixed(0), i)
        


        var offsetToFirstLine = topLine + 1
        var totalSongDistance = Object.values(songObject).reduce((a,obj) => a + obj.duration * unitDistance, 0)
        
        
        
        ctxAnim.clearRect(0, 0, ANIMATION.width, ANIMATION.height)
        
        const numberOfStaves = Math.ceil(totalSongDistance/(barWidth))

        currentStaff = Math.floor(((durationOfNotesPlayed + noteElapsed + 26)*0.001 * unitDistance) / (barWidth))
            // SMUDGE factor, that 26 is looking 26 milliseconds into the future to determine whether the bar is within 26 milliseconds of the next line's first note. Why 26 ? Not sure, I think and hope that it is just javascript's refresh rate, hopefully it is NOT my buffer end length or my 0.25 ending note... 'cause I can't wrap my head around either of those.
            // 26 milliseconds = 0.026 * unitDistance, unitDistance = 1 beat in pixels, bpm = 30, so 2 seconds per beat, 0.026/2 beats, === 0.013 pixels, Almost certainly nothing to do with the buffer or the ending note
            // logging shows that there is a 16 to 17 ms window between each call, that is 1 / 60th of a second: the framerate.
            // This can vary between screens. Not sure if I can get access to the refresh rate programmatically

        y = distanceBetweenStaves * Math.floor((durationOfNotesPlayed*0.001 * unitDistance) / (barWidth))

        // console.log(totalSongDistance%barWidth, Math.floor(totalSongDistance / barWidth))
        if (x >= (totalSongDistance % (barWidth) - 5 || barWidth - 5 )
        && y ===  160 * (numberOfStaves - 1)) {
            x = 0
            i = 0
            start = undefined
            SOUND.close().then(()=> SOUND = new AudioContext())
            return
        } 
        ctxAnim.fillStyle = "black"
        ctxAnim.fillRect(
            startStaffX + initialOffset + 5.5 + x, 
            offsetToFirstLine + y, 
            1, 
            99)
            // if (y === 2 * 160) return
        
        window.requestAnimationFrame(loop)
    }


        // |~~~~~~~~~~~~~~ -- | Sound | -- ~~~~~~~~~~~~~~| \\


    function playSound(frequency, time, i, noteDuration) {
        const osc =  SOUND.createOscillator()
        const gainNode = SOUND.createGain()
        osc.connect(gainNode)
        gainNode.connect(SOUND.destination)
        gainNode.gain.exponentialRampToValueAtTime(0.1, SOUND.currentTime + time )
        gainNode.gain.linearRampToValueAtTime(0.00001, SOUND.currentTime + noteDuration + time)
        // gainNode.gain.linearRampToValueAtTime(0, SOUND.currentTime + time + duration)
        osc.type = 'triangle'
        osc.frequency.value = frequency
        osc.start(SOUND.currentTime + time)
        // console.log(SOUND.state)
        // osc.stop(SOUND.currentTime + duration + time)
    }
    
    function play() {
        if (start) return



        // Initialisation for animation vVv - watch for namespace issues
        x = 0
        start = undefined
        pauseTime = 0
        animationPaused = false
        i = 0
        
        document.getElementById("pause").innerText = "Pause"

        window.requestAnimationFrame(loop)

        for (let i = 0; i < Object.keys(songObject).length; i++) {
            const noteName = songObject[i].name
            const noteNumber = i
            const noteDuration = songObject[i].duration
            const songElapsed = Object.values(songObject).slice(0,i).reduce((acc, obj)=> acc + obj.duration, 0)
            playSound(frequencyNoteMap[noteName], songElapsed, noteNumber, noteDuration)
        }

        
    }

    function pausePlayback() {
        if (!SOUND) return
        if (SOUND.state === "running"){
            SOUND.suspend().then(()=>{document.getElementById("pause").innerText = "Unpause"; animationPaused = true})
        }
        else if (SOUND.state === "suspended") {
            SOUND.resume().then(() => {document.getElementById("pause").innerText = "Pause"; animationPaused = false})
        }
        else return
    }

    function stopPlayback() {
        if (SOUND.state === "running") {
            animationStopped = true
            SOUND.close().then(() => {SOUND = new AudioContext()})
        }
        else if (SOUND.state === "suspended") {
            animationPaused = false
            animationStopped = true
            SOUND.close().then(() => {document.getElementById("pause").innerText = "Pause"; SOUND = new AudioContext()})

        }
        else return
    }


    randomise()

</script>
</html>