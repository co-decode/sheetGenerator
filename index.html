<!DOCTYPE html>
<html lang="en">
<head>
    <title>Sheet Music Generator</title>
    <link rel="icon" href="./music.svg">
    <!-- <link rel="preload" href="index.css" as="style"> -->
    <style>
    body {
        margin: 0;
        /* overflow:hidden; */
    }
    #animation {
        position:absolute;
        top: 0;
    }
    #sound {
        position:absolute;
        top: 10px;
        left: 10px;
    }
    #randomise {
        position: absolute;
        top: 10px;
        left: 200px;
    }
    #distance {
        position: absolute;
        top: 10px;
        left: 400px;
    }
    #pause {
        position: absolute;
        top: 10px;
        left: 600px;
    }
    #stop {
        position: absolute;
        top: 10px;
        left: 800px;
    }
    #replay {
        position: absolute;
        top: 10px;
        left: 1000px;
    }
    #bpm {
        position: absolute;
        top: 265px;
        left: 5px;

    }
    #start_metronome {
        position: absolute;
        top: 265px;
        left: 205px;     
    }
    #stop_metronome {
        position: absolute;
        top: 265px;
        left: 355px;
    }
    #metronome_label {
        position: absolute;
        top: 265px;
        left: 505px;
    }
    </style>
</head>
<body>
    <canvas id="sheet-music"></canvas>
    <canvas id="animation"></canvas>
    <button id="sound" onClick="play()">Play Sound</button>
    <button id="randomise" onClick="randomise()">Randomise</button>
    <button id="pause" onClick="pausePlayback()">Pause</button>
    <button id="stop" onClick="stopPlayback()">Stop</button>
    <button id="replay" onClick="toggleReplay()">Replay: Off</button>
    <label id="bpm">BPM:
        <input id="bpmInput" type="number" min="10" max="320" />
    </label>
    <div id="distance"></div>

    <button id="start_metronome" onclick="startMetronome()">Start Metronome</button>
    <button id="stop_metronome" onclick="stopMetronome()">Stop Metronome</button>
    <label id="metronome_label">
        BPM:&nbsp;
        <input id="metronomeBPM"/>
    </label>
</body>
<script>
    'use strict'
    var bpmInput = document.getElementById('bpmInput')
    var CANVAS = document.getElementById('sheet-music')
    var ANIMATION = document.getElementById('animation')
    var ctxAnim = ANIMATION.getContext('2d')
    var ctx = CANVAS.getContext('2d')
    ctx.font = "40px bravura"


    var SOUND

    var BUTTON = document.getElementById('sound')

    const trebleObject = {}
    const bassObject = {}
    const songDurations = []
    const songNoteNames = []

    const noteHead = {
        4:      `\ue0a2`,
        2:      `\ue0a3`,
        1:      `\ue0a4`,
        0.5:    `\ue0a4`,
        0.25:   `\ue0a4`
    }

    const frequencyNoteMap440 = {
        "C0":16.35,
        "C#0/Db0":17.32,
        "D0":18.35,
        "D#0/Eb0":19.45,
        "E0":20.60,
        "F0":21.83,
        "F#0/Gb0":23.12,
        "G0":24.50,
        "G#0/Ab0":25.96,
        "A0":27.50,
        "A#0/Bb0":29.14,
        "B0":30.87,
        "C1":32.70,
        "C#1/Db1":34.65,
        "D1":36.71,
        "D#1/Eb1":38.89,
        "E1":41.20,
        "F1":43.65,
        "F#1/Gb1":46.25,
        "G1":49.00,
        "G#1/Ab1":51.91,
        "A1":55.00,
        "A#1/Bb1":58.27,
        "B1":61.74,
        "C2":65.41,
        "C#2/Db2":69.30,
        "D2":73.42,
        "D#2/Eb2":77.78,
        "E2":82.41,
        "F2":87.31,
        "F#2/Gb2":92.50,
        "G2":98.00,
        "G#2/Ab2":103.83,
        "A2":110.00,
        "A#2/Bb2":116.54,
        "B2":123.47,
        "C3":130.81,
        "C#3/Db3":138.59,
        "D3":146.83,
        "D#3/Eb3":155.56,
        "E3":164.81,
        "F3":174.61,
        "F#3/Gb3":185.00,
        "G3":196.00,
        "G#3/Ab3":207.65,
        "A3":220.00,
        "A#3/Bb3":233.08,
        "B3":246.94,
        "C4":261.63,
        "C#4/Db4":277.18,
        "D4":293.66,
        "D#4/Eb4":311.13,
        "E4":329.63,
        "F4":349.23,
        "F#4/Gb4":369.99,
        "G4":392.00,
        "G#4/Ab4":415.30,
        "A4":440.00,
        "A#4/Bb4":466.16,
        "B4":493.88,
        "C5":523.25,
        "C#5/Db5":554.37,
        "D5":587.33,
        "D#5/Eb5":622.25,
        "E5":659.25,
        "F5":698.46,
        "F#5/Gb5":739.99,
        "G5":783.99,
        "G#5/Ab5":830.61,
        "A5":880.00,
        "A#5/Bb5":932.33,
        "B5":987.77,
        "C6":1046.50,
        "C#6/Db6":1108.73,
        "D6":1174.66,
        "D#6/Eb6":1244.51,
        "E6":1318.51,
        "F6":1396.91,
        "F#6/Gb6":1479.98,
        "G6":1567.98,
        "G#6/Ab6":1661.22,
        "A6":1760.00,
        "A#6/Bb6":1864.66,
        "B6":1975.53,
        "C7":2093.00,
        "C#7/Db7":2217.46,
        "D7":2349.32,
        "D#7/Eb7":2489.02,
        "E7":2637.02,
        "F7":2793.83,
        "F#7/Gb7":2959.96,
        "G7":3135.96,
        "G#7/Ab7":3322.44,
        "A7":3520.00,
        "A#7/Bb7":3729.31,
        "B7":3951.07,
        "C8":4186.01,
        "C#8/Db8":4434.92,
        "D8":4698.63,
        "D#8/Eb8":4978.03,
        "E8":5274.04,
        "F8":5587.65,
        "F#8/Gb8":5919.91,
        "G8":6271.93,
        "G#8/Ab8":6644.88,
        "A8":7040.00,
        "A#8/Bb8":7458.62,
        "B8":7902.13
    }

    const frequencyNoteMap432 = {
        "C0":16.05,
        "C#0/Db0":17.01,
        "D0":18.02,
        "D#0/Eb0":19.09,
        "E0":20.23,
        "F0":21.43,
        "F#0/Gb0":22.70,
        "G0":24.05,
        "G#0/Ab0":25.48,
        "A0":27.00,
        "A#0/Bb0":28.61,
        "B0":30.31,
        "C1":32.11,
        "C#1/Db1":34.02,
        "D1":36.04,
        "D#1/Eb1":38.18,
        "E1":40.45,
        "F1":42.86,
        "F#1/Gb1":45.41,
        "G1":48.11,
        "G#1/Ab1":50.97,
        "A1":54.00,
        "A#1/Bb1":57.21,
        "B1":60.61,
        "C2":64.22,
        "C#2/Db2":68.04,
        "D2":72.08,
        "D#2/Eb2":76.37,
        "E2":80.91,
        "F2":85.72,
        "F#2/Gb2":90.82,
        "G2":96.22,
        "G#2/Ab2":101.94,
        "A2":108.00,
        "A#2/Bb2":114.42,
        "B2":121.23,
        "C3":128.43,
        "C#3/Db3":136.07,
        "D3":144.16,
        "D#3/Eb3":152.74,
        "E3":161.82,
        "F3":171.44,
        "F#3/Gb3":181.63,
        "G3":192.43,
        "G#3/Ab3":203.88,
        "A3":216.00,
        "A#3/Bb3":228.84,
        "B3":242.45,
        "C4":256.87,
        "C#4/Db4":272.14,
        "D4":288.33,
        "D#4/Eb4":305.47,
        "E4":323.63,
        "F4":342.88,
        "F#4/Gb4":363.27,
        "G4":384.87,
        "G#4/Ab4":407.75,
        "A4":432.00,
        "A#4/Bb4":457.69,
        "B4":484.90,
        "C5":513.74,
        "C#5/Db5":544.29,
        "D5":576.65,
        "D#5/Eb5":610.94,
        "E5":647.27,
        "F5":685.76,
        "F#5/Gb5":726.53,
        "G5":769.74,
        "G#5/Ab5":815.51,
        "A5":864.00,
        "A#5/Bb5":915.38,
        "B5":969.81,
        "C6":1027.47,
        "C#6/Db6":1088.57,
        "D6":1153.30,
        "D#6/Eb6":1221.88,
        "E6":1294.54,
        "F6":1371.51,
        "F#6/Gb6":1453.07,
        "G6":1539.47,
        "G#6/Ab6":1631.01,
        "A6":1728.00,
        "A#6/Bb6":1830.75,
        "B6":1939.61,
        "C7":2054.95,
        "C#7/Db7":2177.14,
        "D7":2306.60,
        "D#7/Eb7":2443.76,
        "E7":2589.07,
        "F7":2743.03,
        "F#7/Gb7":2906.14,
        "G7":3078.95,
        "G#7/Ab7":3262.03,
        "A7":3456.00,
        "A#7/Bb7":3661.50,
        "B7":3879.23,
        "C8":4109.90,
        "C#8/Db8":4354.29,
        "D8":4613.21,
        "D#8/Eb8":4887.52,
        "E8":5178.15,
        "F8":5486.06,
        "F#8/Gb8":5812.28,
        "G8":6157.89,
        "G#8/Ab8":6524.06,
        "A8":6912.00,
        "A#8/Bb8":7323.01,
        "B8":7758.46
    }
    /* const offsetNoteMap = {
        "C0":38,
        "D0":37,
        "E0":36,
        "F0":35,
        "G0":34,
        "A0":33,
        "B0":32,
        "C1":31,
        "D1":30,
        "E1":29,
        "F1":28,
        "G1":27,
        "A1":26,
        "B1":25,
        "C2":24,
        "D2":23,
        "E2":22,
        "F2":21,
        "G2":20,
        "A2":19,
        "B2":18,
        "C3":17,
        "D3":16,
        "E3":15,
        "F3":14,
        "G3":13,
        "A3":12,
        "B3":11,
        "C4":10,
        "D4":9,
        "E4":8,
        "F4":7,
        "G4":6,
        "A4":5,
        "B4":4,
        "C5":3,
        "D5":2,
        "E5":1,
        "F5":0,
        "F#5/Gb5": 0,
        "G5":-1,
        "A5":-2,
        "B5":-3,
        "C6":-4,
        "D6":-5,
        "E6":-6,
        "F6":-7,
        "G6":-8,
        "A6":-9,
        "B6":-10,
        "C7":-11,
        "D7":-12,
        "E7":-13,
        "F7":-14,
        "G7":-15,
        "A7":-16,
        "B7":-17,
        "C8":-18,
        "D8":-19,
        "E8":0,
        "F8":0,
        "G8":0,
        "A8":0,
        "B8":0,
    } */

    const offsetMap = {
        38:["C0","C#0"],
        37:["D0","D#0","Db0"],
        36:["E0","Eb0"],
        35:["F0","F#0"],
        34:["G0","G#0","Gb0"],
        33:["A0","A#0","Ab0"],
        32:["B0","Bb0"],
        31:["C1","C#1"],
        30:["D1","D#1","Db1"],
        29:["E1","Eb1"],
        28:["F1","F#1"],
        27:["G1","G#1","Gb1"],
        26:["A1","A#1","Ab1"],
        25:["B1","Bb1"],
        24:["C2","C#2"],
        23:["D2","D#2","Db2"],
        22:["E2","Eb2"],
        21:["F2","F#2"],
        20:["G2","G#2","Gb2"],
        19:["A2","A#2","Ab2"],
        18:["B2","Bb2"],
        17:["C3","C#3"],
        16:["D3","D#3","Db3"],
        15:["E3","Eb3"],
        14:["F3","F#3"],
        13:["G3","G#3","Gb3"],
        12:["A3","A#3","Ab3"],
        11:["B3","Bb3"],
        10:["C4","C#4"],
        9:["D4","D#4","Db4"],
        8:["E4","Eb4"],
        7:["F4","F#4"],
        6:["G4","G#4","Gb4"],
        5:["A4","A#4","Ab4"],
        4:["B4","Bb4"],
        3:["C5","C#5"],
        2:["D5","D#5","Db5"],
        1:["E5","Eb5"],
        0:["F5","F#5"],
        "-1":["G5","G#5","Gb5"],
        "-2":["A5","A#5","Ab5"],
        "-3":["B5","Bb5"],
        "-4":["C6","C#6"],
        "-5":["D6","D#6","Db6"],
        "-6":["E6","Eb6"],
        "-7":["F6","F#6"],
        "-8":["G6","G#6","Gb6"],
        "-9":["A6","A#6","Ab6"],
        "-10":["B6","Bb6"],
        "-11":["C7","C#7"],
        "-12":["D7","D#7","Db7"],
        "-13":["E7","Eb7"],
        "-14":["F7","F#7"],
        "-15":["G7","G#7","Gb7"],
        "-16":["A7","A#7","Ab7"],
        "-17":["B7","Bb7"],
        "-18":["C8","C#8"],
        "-19":["D8","D#8","Db8"],
        "-10":["E8","Eb8"],
        "-21":["F8","F#8"],
        "-22":["G8","G#8","Gb8"],
        "-23":["A8","A#8","Ab8"],
        "-24":["B8","Bb8"]
    }

   /*  const cPentatonicMajor = [
        "C5",
        "D5",
        "E5",
        "G5",
        "A5"
    ]
    const gMajor = [
        "G4",
        "A4",
        "B4",
        "C5",
        "D5",
        "E5",
        "F#5/Gb5",
        "G5"
    ]

    const bassGNotes = [
        "G2",
        "C3",
        "E3"
    ] */
    
    const keyObject = {
        C: [null, 0],
        G: ['SHARP', 1],
        D: ['SHARP', 2],
        A: ['SHARP', 3],
        E: ['SHARP', 4],
        B: ['SHARP', 5],
        F: ['FLAT', 1],
        "A#/Bb": ['FLAT', 2],
        "D#/Eb": ['FLAT', 3],
        "G#/Ab": ['FLAT', 4],
        Db: ['FLAT', 5],
        "F#": ['SHARP', 6],
        Gb: ['FLAT', 6],
        "C#": ['SHARP', 7],
        Cb: ['FLAT', 7],
    }

    const majorScaleHeptatonic = [0, 2, 4, 5, 7, 9,11,12]
    const majorScaleTritonic = [0, 4, 7]

    var key = "D"
    var rootOctaveTreble = 4
    var rootOctaveBass = 2

    var scaleTypeTreble = majorScaleHeptatonic
    var scaleTypeBass = majorScaleTritonic

    // var initialNoteTreble = "F4"
    // var initialNoteBass = "F2"

    var builtScaleTreble 

    var builtScaleBass

   /*  function noteConversion(note) {
        if (["A#", "Bb", "D#", "Eb", "G#", "Ab"].includes(note)) {
            note = Object.keys(frequencyNoteMap440).find(name => name.includes(note)).replace(/\d/g, "")
            return note
        }
    }
    
    function getInitialNote(key, rootOctave) {
        let note = key + rootOctave
        return Object.keys(frequencyNoteMap440).find(name => name.includes(note))
    }
     */
    
    function buildScale() {
        let initialNoteTreble = key + rootOctaveTreble
        let initialNoteBass = key + rootOctaveBass
        
        const notes = Object.keys(frequencyNoteMap440)

        if (["A#", "Bb", "D#", "Eb", "G#", "Ab"].some(name => name === key)) {
            key = notes.find(name => name.includes(key)).replace(/\d/g, "")
        }

        if (key.includes("b") || key.includes("#")) {
            if (key === "Cb") {
                initialNoteTreble = notes.find(name => name.includes("B" + rootOctaveTreble))
                initialNoteBass = notes.find(name => name.includes("B" + rootOctaveBass))
            }
            else {
                initialNoteTreble = notes.find(name => name.includes(initialNoteTreble))
                initialNoteBass = notes.find(name => name.includes(initialNoteBass))
            }
        }
        
        const initialIndexTreble = notes.findIndex((val) => val === initialNoteTreble)
        const initialIndexBass = notes.findIndex((val) => val === initialNoteBass)

         builtScaleTreble = Array(scaleTypeTreble.length).fill(null).map((val, index) => notes[initialIndexTreble + scaleTypeTreble[index]])
         builtScaleBass = Array(scaleTypeBass.length).fill(null).map((val, index) => notes[initialIndexBass + scaleTypeBass[index]])

    }

    buildScale()


    

    var durations = [
        /* 0.25,  */0.5, 1, 2
    ]

    var bassDurations = [
        1,2
    ]



    var bpm = 60
    bpmInput.value = bpm
    bpmInput.addEventListener("change", (e) => {
        bpm = parseInt(e.target.value); 
        secondsPerBeat = 60 / bpm; 
        unitDistance = barWidth / (numberOfBeatsPerBar); 
        stopPlayback(); 
        animationStopped = false; 
        fitToScreen();
    })
    const numberOfMeasures = 2
    const timeSignatureBeats = 4
    // timeSignatureUnit = 4
    var secondsPerBeat = 60 / bpm         
    var topLine = 50
    var distanceBetweenStaves = 160
    var startStaffX = 40
    var initialOffset = 90 + keyObject[key][1] * 10
    var bufferToEnd = 4
    var barWidth = (window.innerWidth - 2 * startStaffX - initialOffset - bufferToEnd)
    const numberOfMeasuresPerBar = 2
    const numberOfBeatsPerBar = numberOfMeasuresPerBar * timeSignatureBeats
    var unitDistance = barWidth / (numberOfBeatsPerBar)
    // p / bar  /  beat / bar = pixels / beat


    function keySignatures(sharpOrFlat, noOfGlyphs) {
        var keySignatureOffset = 70
        var glyphWidthUnit = 10
        var semiToneDistance = 5
        var distanceBetweenTopLines = 12 * semiToneDistance
        var treblePositions, bassPositions
        if (sharpOrFlat === "SHARP") {
            treblePositions = [0, 3, -1, 2, 5, 1, 4]
            bassPositions = [1, 5, 1, 4, 7, 3, 6]
            Array(noOfGlyphs).fill(null).forEach((nothing, ind) => {
                ctx.fillText(`\ue262`, 
                startStaffX + keySignatureOffset + glyphWidthUnit * ind,
                topLine + semiToneDistance * treblePositions[ind]) 
                ctx.fillText(`\ue262`, 
                startStaffX + keySignatureOffset + glyphWidthUnit * ind,
                topLine + distanceBetweenTopLines + semiToneDistance * bassPositions[ind])
            })
        }
        else if (sharpOrFlat === "FLAT") {
            treblePositions = [4, 1, 5, 2, 6, 3, 7]
            bassPositions = [6, 3, 7, 4, 8, 5, 9]
            Array(noOfGlyphs).fill(null).forEach((nothing, ind) => {
                ctx.fillText(`\ue260`, 
                startStaffX + keySignatureOffset + glyphWidthUnit * ind,
                topLine + semiToneDistance * treblePositions[ind]) 
                ctx.fillText(`\ue260`, 
                startStaffX + keySignatureOffset + glyphWidthUnit * ind,
                topLine + distanceBetweenTopLines + semiToneDistance * bassPositions[ind])
            })

        }
        /* 
        ctx.fillText(`\ue260`, startStaffX + 70, topLine + 20)   // Flat Signatures - Treble
        ctx.fillText(`\ue260`, startStaffX + 80, topLine + 5)
        ctx.fillText(`\ue260`, startStaffX + 90, topLine + 25)
        ctx.fillText(`\ue260`, startStaffX + 100, topLine + 10)
        ctx.fillText(`\ue260`, startStaffX + 110, topLine + 30)
        ctx.fillText(`\ue260`, startStaffX + 120, topLine + 15)
        ctx.fillText(`\ue260`, startStaffX + 130, topLine + 35)
    
        ctx.fillText(`\ue260`, startStaffX + 70, topLine + 60 + 30)   // Flat Signatures - Bass
        ctx.fillText(`\ue260`, startStaffX + 80, topLine + 60 + 15)
        ctx.fillText(`\ue260`, startStaffX + 90, topLine + 60 + 35)
        ctx.fillText(`\ue260`, startStaffX + 100, topLine + 60 + 20)
        ctx.fillText(`\ue260`, startStaffX + 110, topLine + 60 + 40)
        ctx.fillText(`\ue260`, startStaffX + 120, topLine + 60 + 25)
        ctx.fillText(`\ue260`, startStaffX + 130, topLine + 60 + 45)

        ctx.fillText(`\ue262`, startStaffX + 70, topLine + 0)   // Sharp Signatures - Treble
        ctx.fillText(`\ue262`, startStaffX + 80, topLine + 15)
        ctx.fillText(`\ue262`, startStaffX + 90, topLine - 5)
        ctx.fillText(`\ue262`, startStaffX + 100, topLine + 10)
        ctx.fillText(`\ue262`, startStaffX + 110, topLine + 25)
        ctx.fillText(`\ue262`, startStaffX + 120, topLine + 5)
        ctx.fillText(`\ue262`, startStaffX + 130, topLine + 20)
        
        ctx.fillText(`\ue262`, startStaffX + 70, topLine + 60 + 10)   // Sharp Signatures - Bass
        ctx.fillText(`\ue262`, startStaffX + 80, topLine + 60 + 25)
        ctx.fillText(`\ue262`, startStaffX + 90, topLine + 60 + 5)
        ctx.fillText(`\ue262`, startStaffX + 100, topLine + 60 + 20)
        ctx.fillText(`\ue262`, startStaffX + 110, topLine + 60 + 35)
        ctx.fillText(`\ue262`, startStaffX + 120, topLine + 60 + 15)
        ctx.fillText(`\ue262`, startStaffX + 130, topLine + 60 + 30) */


        // initialOffset += noOfGlyphs * glyphWidthUnit
    }


    function randomise(){
        SOUND = new AudioContext()

        let currentDistance = 0
        let index = 0
        let bassIndex = 0
        Object.keys(trebleObject).forEach(noteNumber => delete trebleObject[noteNumber])
        Object.keys(bassObject).forEach(noteNumber => delete bassObject[noteNumber])
        
        Array(numberOfMeasures).fill(null).forEach((nothing, measure) => {                 // Number of Musical Measures
        while (currentDistance < timeSignatureBeats) {
            const bassNLU = bassDurations[Math.floor(Math.random() * bassDurations.length)]

            bassObject[bassIndex] = {
                duration: bassNLU,
                name: builtScaleBass[Math.floor(Math.random() * builtScaleBass.length)]
            }

            currentDistance += bassNLU

            const distanceLeft = timeSignatureBeats - currentDistance
            if (bassDurations.at(-1) > distanceLeft){              // Cut out notes which would exceed bar length
                bassDurations = bassDurations.filter(dur => dur <= distanceLeft)
            }
            bassIndex++
        }
        currentDistance = 0
        bassDurations = [1,2]
        while (currentDistance < timeSignatureBeats) {
            const noteLengthUnit = durations[Math.floor(Math.random()*durations.length)]


    
            trebleObject[index] = {
                duration: noteLengthUnit, 
                name: builtScaleTreble[Math.floor(Math.random() * builtScaleTreble.length)]
            }

            currentDistance += noteLengthUnit       
            const distanceLeft = timeSignatureBeats - currentDistance
            if (durations.at(-1) > distanceLeft){              // Cut out notes which would exceed bar length
                durations = durations.filter(dur => dur <= distanceLeft)
            }
            index++
        }
        currentDistance = 0
        durations = [/* 0.25, */ 0.5, 1, 2]
        })
        var totalSongDistance = Object.values(trebleObject).reduce((a,obj) => a + obj.duration * unitDistance, 0)

        const distanceDiv = document.getElementById("distance")
        distanceDiv.innerText = `${totalSongDistance} px`

        fitToScreen()
    }

    
    function fitToScreen() {
        CANVAS.width = window.innerWidth
        CANVAS.height = window.innerHeight * 2
        ANIMATION.width = window.innerWidth
        ANIMATION.height = window.innerHeight * 2
        barWidth = window.innerWidth - 2 * startStaffX - initialOffset - bufferToEnd
        unitDistance = barWidth / (numberOfBeatsPerBar)
        drawSheet()
    }
   
    
    
    window.addEventListener('resize', fitToScreen)
    
    function drawSheet() {
        var {width, height} = CANVAS
        ctx.fillStyle = "black"
        ctx.font = "40px bravura"
        ctx.fillText("\uE084", startStaffX + 43, topLine + 10)                                 // Time signatures  - treble
        ctx.fillText("\uE084", startStaffX + 43, topLine + 30)
        
        ctx.fillText("\uE084", startStaffX + 43, topLine + 60 + 10)               //  - bass
        ctx.fillText("\uE084", startStaffX + 43, topLine + 60 + 30)

        keySignatures(...keyObject[key])                                                               // Key Signatures

        // |~~~~~~~~~~~~~~ -- | Note placement | -- ~~~~~~~~~~~~~~| \\
        
        var halfToneDistance = 5
        var songDistance = 0        // The number of pixels from the start to the current note
        var totalSongDistance = Object.values(trebleObject).reduce((a,obj) =>
            a + obj.duration * unitDistance, 0)
        var numberOfStaves = Math.ceil(totalSongDistance/barWidth)

        function drawNotes(songObject) {
            Object.values(songObject).forEach((obj,noteNumber)=> {
            const noteDuration = obj.duration
            const offset = Object.keys(offsetMap)
                .find(offsetKey => offsetMap[offsetKey]
                    .some(noteName=> new RegExp(noteName)
                        .test(obj.name)))

            
            ctx.fillText(noteHead[noteDuration],// Draw note head
                startStaffX + initialOffset + songDistance % barWidth, 
                topLine + 0.5 + halfToneDistance * offset + distanceBetweenStaves * Math.floor(songDistance / barWidth))
            if (noteDuration <= 2) {            // Draw note bars and tails
                if (offset > 4) {
                    ctx.fillRect(
                        startStaffX + initialOffset + songDistance % barWidth + 10,
                        topLine - 1 + halfToneDistance * offset + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                        2,
                        -30)
                    if (noteDuration === 0.5) {
                        ctx.fillText('\ue240', 
                        startStaffX + initialOffset + songDistance % barWidth + 10, 
                        topLine - 1 + halfToneDistance * offset + distanceBetweenStaves * Math.floor(songDistance / barWidth) - 35)
                    }
                    else if (noteDuration === 0.25) {
                        ctx.fillText('\ue242', 
                        startStaffX + initialOffset + songDistance % barWidth + 10, 
                        topLine - 1 + halfToneDistance * offset + distanceBetweenStaves * Math.floor(songDistance / barWidth) - 35)
                    }
                }
                else {
                    ctx.fillRect(
                        startStaffX + initialOffset + songDistance % barWidth,
                        topLine + 0.5 + halfToneDistance * offset + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                        2,
                        30)
                    if (noteDuration === 0.5) {
                        ctx.fillText('\ue241', startStaffX + initialOffset + songDistance % barWidth,
                        topLine - 1 + halfToneDistance * offset + distanceBetweenStaves * Math.floor(songDistance / barWidth) + 35)
                    }
                    else if (noteDuration === 0.25) {
                        ctx.fillText('\ue243', startStaffX + initialOffset + songDistance % barWidth,
                        topLine - 1 + halfToneDistance * offset + distanceBetweenStaves * Math.floor(songDistance / barWidth) + 35)
                    }
                }
            }

            function findOffset(note) {
                return parseInt(Object.keys(offsetMap).find(offset => offsetMap[offset].includes(note)))
            }

            if (obj.name === "C4") {            // C4 bar
                ctx.fillRect(
                    startStaffX + initialOffset + songDistance % barWidth - 0.3 * 30, 
                    topLine + halfToneDistance * findOffset("C4") + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                    30,
                    1)      
                }
            else if (findOffset(obj.name) < findOffset("G5")) {
                ctx.fillRect(
                    startStaffX + initialOffset + songDistance % barWidth - 0.3 * 30, 
                    topLine + halfToneDistance * findOffset("A5") + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                    30,
                    1)
                if (findOffset(obj.name) < findOffset("B5")) {
                    ctx.fillRect(
                        startStaffX + initialOffset + songDistance % barWidth - 0.3 * 30, 
                        topLine + halfToneDistance * findOffset("C6") + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                        30,
                        1)
                }
            }
            else if (findOffset(obj.name) > findOffset("F2")) {
                ctx.fillRect(
                    startStaffX + initialOffset + songDistance % barWidth - 0.3 * 30, 
                    topLine + halfToneDistance * findOffset("E2") + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                    30,
                    1)
                if (findOffset(obj.name) > findOffset("D2")) {
                    ctx.fillRect(
                        startStaffX + initialOffset + songDistance % barWidth - 0.3 * 30, 
                        topLine + halfToneDistance * findOffset("C2") + distanceBetweenStaves * Math.floor(songDistance / barWidth),
                        30,
                        1)
                }
                
            }
            
            songDistance += unitDistance * noteDuration
        })
        songDistance = 0
        }

        drawNotes(trebleObject)
        drawNotes(bassObject)
        
        Array(numberOfStaves).fill(null).forEach((v, index) => {                                    // Number of grand staves
            ctx.font = `100px bravura`
            ctx.fillText("\uE000", 25, topLine + 100 + distanceBetweenStaves * index)               // Staff Bracket
            ctx.font = "40px bravura"
            ctx.fillText("\uE050", startStaffX + 10, topLine + 30 + distanceBetweenStaves * index)  // Treble Clef
            ctx.fillText(`\ue062`, startStaffX + 10,topLine + 70.5 + distanceBetweenStaves * index) // Bass Clef  

            
            Array(numberOfMeasuresPerBar).fill(null).forEach((nothing, measureIndex) => {           // Measure bars
                if (!measureIndex) return
                function drawLine(offset) {ctx.fillRect(
                    barWidth / (numberOfBeatsPerBar / timeSignatureBeats) * measureIndex + startStaffX + initialOffset - offset, 
                    topLine + distanceBetweenStaves * index, 
                    1.5, 100)}
                drawLine(5)
                }
            )

            Array(2).fill(null).forEach((v, ind) => {                                   // Treble and Bass staves
                ctx.fillRect(startStaffX + 10,topLine + 50 + distanceBetweenStaves*index,30,1) // C4 bar
                
                ctx.fillRect(startStaffX,topLine + distanceBetweenStaves * index,2,100)        // Start Staff
                ctx.fillRect(width - startStaffX,topLine + distanceBetweenStaves * index,2,101)  // End staff

                

                Array(5).fill(null).forEach( (v,i) =>                                   // Staff lines
                    ctx.fillRect(startStaffX, (topLine) + 10 * i + 60 * ind + distanceBetweenStaves * index, width - 2 * startStaffX, 1) )
            })  
            
        })

    }
   


   

        
        // |~~~~~~~~~~~~~~ -- | Bar animation | -- ~~~~~~~~~~~~~~| \\

        var x = 0
        var y = 0
        var dir = "FORWARD"
        var start = undefined, pauseTime = 0, elapsed
        var animationPaused = false
        var animationStopped = false
        var replay = false
        let i = 0

        // var songDistance = 0
        var currentStaff = 0
    

    function loop(timestamp) {
        if (start === undefined) {
            start = timestamp
        }
        if (animationPaused) {
            pauseTime = timestamp - start - elapsed  
            window.requestAnimationFrame(loop) 
            return
        }
        if (animationStopped) {
            x = 0;
            i = 0;
            start = undefined;
            pauseTime = 0;
            animationStopped = false; 
            ctxAnim.clearRect(0, 0, ANIMATION.width, ANIMATION.height);
            return
        }
        
        elapsed = timestamp - start - pauseTime
        
        const totalTimeWhenNextNotePlayed = Object.values(trebleObject).slice(0,i).reduce((a,v) => a + v.duration, 0) * unitDistance/secondsPerBeat
        
        if (x + barWidth * currentStaff >= 
        Object.values(trebleObject)
        .slice(0,i)
        .reduce((a,v) => a + v.duration, 0) * unitDistance/secondsPerBeat
        && i <  Object.values(trebleObject).length - 1
        ) i++
        
        const durationOfNotesPlayed = Object.values(trebleObject).slice(0,i-1).reduce((a,v) => a + v.duration, 0) * 1000
        const noteElapsed = elapsed - durationOfNotesPlayed
        const noteDuration = trebleObject[i-1].duration
        // songDistance = Object.values(trebleObject).slice(0,i).reduce((a,obj) => a + obj.duration * unitDistance, 0)
        
        
        // x = (durationOfNotesPlayed*0.001 * unitDistance/secondsPerBeat) % (barWidth) + (noteElapsed*0.001/noteDuration) * unitDistance/secondsPerBeat * noteDuration
        x = (durationOfNotesPlayed * 0.001 * unitDistance/secondsPerBeat) % (barWidth) + (noteElapsed*0.001) * unitDistance/secondsPerBeat
        
        
        
        var offsetToFirstLine = topLine + 1
        var totalSongDistance = Object.values(trebleObject).reduce((a,obj) => a + obj.duration * unitDistance, 0)
        
        ctxAnim.clearRect(0, 0, ANIMATION.width, ANIMATION.height)
        
        const numberOfStaves = Math.ceil(totalSongDistance/(barWidth))
        
        currentStaff = Math.floor(((durationOfNotesPlayed + noteElapsed + 26)*0.001 * unitDistance/secondsPerBeat) / (barWidth))
        // SMUDGE factor, that 26 is looking 26 milliseconds into the future to determine whether the bar is within 26 milliseconds of the next line's first note. Why 26 ? Not sure, I think and hope that it is just javascript's refresh rate, hopefully it is NOT my buffer end length or my 0.25 ending note... 'cause I can't wrap my head around either of those.
        // 26 milliseconds = 0.026 * unitDistance, unitDistance = 1 beat in pixels, bpm = 30, so 2 seconds per beat, 0.026/2 beats, === 0.013 pixels, Almost certainly nothing to do with the buffer or the ending note
            // logging shows that there is a 16 to 17 ms window between each call, that is 1 / 60th of a second: the framerate.
            // This can vary between screens. Not sure if I can get access to the refresh rate programmatically
            
            y = distanceBetweenStaves * Math.floor((durationOfNotesPlayed*0.001 * unitDistance/secondsPerBeat) / (barWidth))
            if (
              (x >= (totalSongDistance % (barWidth) || barWidth ) /* - (5 / (secondsPerBeat * 1600 / window.innerWidth)) */
            && y ===  160 * (numberOfStaves - 1)) 
            || y > 160 * (numberOfStaves - 1)) {
            x = 0
            i = 0
            start = undefined
            if (replay) return play();
            SOUND.close().then(()=> SOUND = new AudioContext())
            return
        } 
        ctxAnim.fillStyle = "black"
        ctxAnim.fillRect(
            startStaffX + initialOffset + 5.5 + x, 
            offsetToFirstLine + y, 
            1, 
            99)
            // if (y === 2 * 160) return
        
        window.requestAnimationFrame(loop)
    }


        // |~~~~~~~~~~~~~~ -- | Sound | -- ~~~~~~~~~~~~~~| \\


    function playSound(frequency, time, i, noteDuration) {
        const osc =  SOUND.createOscillator()
        const gainNode = SOUND.createGain()
        osc.connect(gainNode)
        gainNode.connect(SOUND.destination)
        gainNode.gain.exponentialRampToValueAtTime(0.1, SOUND.currentTime + time )
        gainNode.gain.linearRampToValueAtTime(0.00001, SOUND.currentTime + noteDuration + time)
        gainNode.gain.linearRampToValueAtTime(0, SOUND.currentTime + time + noteDuration + 0.1)
        osc.type = 'triangle'
        osc.frequency.value = frequency
        osc.start(SOUND.currentTime + time)
        // osc.stop(SOUND.currentTime + duration + time)
    }
    
    function play() {
        if (start) return
        // Initialisation for animation vVv - watch for namespace issues
        x = 0
        i = 0
        start = undefined
        pauseTime = 0
        animationPaused = false
        
        document.getElementById("pause").innerText = "Pause"

        window.requestAnimationFrame(loop)

        for (let i = 0; i < Object.keys(trebleObject).length; i++) {
            const noteName = trebleObject[i].name
            const noteNumber = i
            const noteDuration = trebleObject[i].duration * secondsPerBeat
            const songElapsed = Object.values(trebleObject).slice(0,i).reduce((acc, obj)=> acc + obj.duration * secondsPerBeat, 0)
            playSound(frequencyNoteMap440[noteName], songElapsed, noteNumber, noteDuration)
        }
        for (let ind = 0; ind < Object.keys(bassObject).length; ind++) {
            const noteName = bassObject[ind].name
            const noteNumber = ind
            const noteDuration = bassObject[ind].duration * secondsPerBeat
            const songElapsed = Object.values(bassObject).slice(0,ind).reduce((acc, obj)=> acc + obj.duration * secondsPerBeat, 0)
            playSound(frequencyNoteMap440[noteName], songElapsed, noteNumber, noteDuration)
        }
    }

    function pausePlayback() {
        if (!SOUND) return
        if (SOUND.state === "running"){
            SOUND.suspend().then(()=>{document.getElementById("pause").innerText = "Unpause"; animationPaused = true})
        }
        else if (SOUND.state === "suspended") {
            SOUND.resume().then(() => {document.getElementById("pause").innerText = "Pause"; animationPaused = false})
        }
        else return
    }

    function stopPlayback() {
        if (SOUND.state === "running") {
            animationStopped = true
            SOUND.close().then(() => {SOUND = new AudioContext()})
        }
        else if (SOUND.state === "suspended") {
            animationPaused = false
            animationStopped = true
            SOUND.close().then(() => {document.getElementById("pause").innerText = "Pause"; SOUND = new AudioContext()})

        }
        else return
    }

    function toggleReplay() {
        replay = !replay
        if (replay) document.getElementById("replay").innerText = "Replay: On"
        else if (!replay) document.getElementById("replay").innerText = "Replay: Off"
    }


    randomise()


    /* Metronome */

    var METRONOME = new AudioContext()
    var metronome_bpm = 120
    var metronome_milliSecondsPerBeat = (60 / metronome_bpm) * 1000
    var metronomeStopped = true
    
    var metronomeBPM = document.getElementById('metronomeBPM')
    var metronome_start
    var metronome_toneIndex 
    metronomeBPM.addEventListener("change", (e) => {
        metronome_bpm = parseInt(e.target.value); 
        metronome_milliSecondsPerBeat = (60 / metronome_bpm) * 1000; 
        // console.log("changed", bpm)
        if (!metronomeStopped) {
            metronomeStopped = true
            METRONOME.close()/* .then(() => {METRONOME = new AudioContext()}) */
        }
    })
    
    function playMetronome() {
        const osc =  METRONOME.createOscillator()
        const gainNode = METRONOME.createGain()
        osc.connect(gainNode)
        gainNode.connect(METRONOME.destination)
        // gainNode.gain.exponentialRampToValueAtTime(0.1, METRONOME.currentTime )
        gainNode.gain.linearRampToValueAtTime(0.1, METRONOME.currentTime )
        gainNode.gain.linearRampToValueAtTime(0, METRONOME.currentTime + (metronome_milliSecondsPerBeat / 1000))
        osc.type = 'sine'
        // osc.frequency.value = frequency
        osc.start(METRONOME.currentTime)
    }

    function stopMetronome() {
        if (!metronomeStopped) {
            metronomeStopped = true
            METRONOME.close()/* .then(() => {METRONOME = new AudioContext()}) */
        }
    }
    
    function startMetronome() {
        window.requestAnimationFrame((timestamp) => {
            if (metronome_start === undefined) {
            metronomeStopped = false
            metronome_start = timestamp;
            metronome_toneIndex = 0
            playMetronome()
        }
        if (metronomeStopped) {
            metronome_start = undefined
            METRONOME = new AudioContext()
            window.cancelAnimationFrame(startMetronome)
            return
        }
        var elapsed = timestamp - metronome_start
        if (parseInt(elapsed - metronome_toneIndex * metronome_milliSecondsPerBeat) >= metronome_milliSecondsPerBeat) {
            console.log(elapsed, metronome_toneIndex)
            metronome_toneIndex++
            playMetronome()
            }
        window.requestAnimationFrame(startMetronome)
        })
    }

</script>
</html>